/**
 * ===================================================================
 * PAYMENT CONTROLLER — Verification & Fulfillment
 * ===================================================================
 * 
 * This is the MOST IMPORTANT security step in the entire flow.
 * 
 * Flow:
 * 1. Frontend sends orderId, paymentId, signature after Razorpay modal closes
 * 2. Backend verifies the HMAC SHA256 signature using Razorpay Secret
 * 3. If signature MATCHES:
 *    - Find the PENDING purchase record by orderId
 *    - Update status to SUCCESS and save the paymentId
 *    - Trigger email delivery with Google Drive link
 *    - Trigger WhatsApp message (optional)
 * 4. If signature FAILS:
 *    - Update purchase status to FAILED
 *    - Return 400 error
 * 
 * ===================================================================
 */

import crypto from 'crypto';
import logger from '../utils/logger.js';
import pb, { authenticateAdmin } from '../lib/pocketbaseAdmin.js';

export const verifyPayment = async (req, res) => {
  const { orderId, paymentId, signature, productId, buyerEmail, buyerPhone, productName, googleDriveLink } = req.body;

  // ── Step 1: Validate required fields ──
  if (!orderId || !paymentId || !signature) {
    return res.status(400).json({ error: 'orderId, paymentId, and signature are required' });
  }

  if (!buyerEmail || !productName || !googleDriveLink) {
    return res.status(400).json({ error: 'buyerEmail, productName, and googleDriveLink are required' });
  }

  const razorpaySecretKey = process.env.RAZORPAY_KEY_SECRET;
  if (!razorpaySecretKey) {
    throw new Error('Razorpay secret key not configured. Set RAZORPAY_KEY_SECRET in .env');
  }

  // ── Step 2: Verify Razorpay HMAC SHA256 Signature ──
  // The signature is generated by Razorpay using: HMAC_SHA256(orderId + "|" + paymentId, secret)
  // We regenerate it server-side and compare — if they match, the payment is authentic.
  const hmac = crypto.createHmac('sha256', razorpaySecretKey);
  hmac.update(`${orderId}|${paymentId}`);
  const generatedSignature = hmac.digest('hex');

  const isSignatureValid = generatedSignature === signature;

  // ── Step 3: Update Purchase Record in PocketBase ──
  try {
    if (!pb.authStore.isValid) {
      await authenticateAdmin();
    }

    // Find the PENDING purchase by orderId
    const purchases = await pb.collection('purchases').getFullList({
      filter: `orderId="${orderId}"`,
      $autoCancel: false,
    });

    if (purchases.length > 0) {
      const purchase = purchases[0];

      if (isSignatureValid) {
        // ✅ Signature matches — Mark as SUCCESS and Link to User
        let userId = null;
        try {
          const userRecord = await pb.collection('users').getFirstListItem(`email="${buyerEmail}"`);
          userId = userRecord.id;
        } catch (e) {
          logger.warn(`Could not find user to link purchase to: ${buyerEmail}`);
        }

        await pb.collection('purchases').update(purchase.id, {
          status: 'SUCCESS',
          paymentId: paymentId,
          user: userId, // Link the purchase to the user!
        }, { $autoCancel: false });
        logger.info(`✅ Purchase ${purchase.id} marked as SUCCESS and linked to user ${userId} (order: ${orderId})`);
      } else {
        // ❌ Signature mismatch — Mark as FAILED
        await pb.collection('purchases').update(purchase.id, {
          status: 'FAILED',
          paymentId: paymentId,
        }, { $autoCancel: false });
        logger.error(`❌ Payment FAILED — signature mismatch for order: ${orderId}`);
        return res.status(400).json({ error: 'Payment verification failed. Signature mismatch.' });
      }
    } else {
      logger.warn(`No PENDING purchase found for orderId: ${orderId}`);
      // Still proceed with email if signature is valid (for backward compat)
    }
  } catch (dbError) {
    logger.warn(`Could not update purchase record: ${dbError.message}`);
    // Non-blocking — continue with email delivery even if DB update fails
  }

  // If signature was invalid and we didn't find a purchase record, fail here
  if (!isSignatureValid) {
    logger.error(`Payment signature mismatch for order: ${orderId}`);
    return res.status(400).json({ error: 'Payment verification failed. Signature mismatch.' });
  }

  logger.info(`Razorpay signature verified successfully for order: ${orderId}`);

  // ── Step 4: Send Product Email (Fulfillment) ──
  logger.info('Sending product email to:', buyerEmail);
  try {
    const emailResponse = await fetch('http://localhost:3001/email/send-product-email', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        buyerEmail,
        productId,
        productName,
        googleDriveLink,
      }),
    });

    if (!emailResponse.ok) {
      logger.warn(`Email delivery failed: ${emailResponse.statusText}`);
    } else {
      logger.info('Product email sent successfully');
    }
  } catch (emailErr) {
    // Non-blocking — payment is already verified, email failure shouldn't block
    logger.error('Error sending email:', emailErr.message);
  }

  // ── Step 5: Send WhatsApp Message (Optional) ──
  if (buyerPhone) {
    logger.info('Triggering WhatsApp automation for:', buyerPhone);
    try {
      const whatsappResponse = await fetch('http://localhost:3001/whatsapp/send-whatsapp', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          customerPhone: buyerPhone,
          productName,
          googleDriveLink,
        }),
      });
      if (!whatsappResponse.ok) {
        logger.warn(`Failed to trigger WhatsApp message: ${whatsappResponse.statusText}`);
      } else {
        logger.info('WhatsApp automation triggered successfully');
      }
    } catch (err) {
      logger.error('Error hitting WhatsApp endpoint:', err.message);
    }
  }

  // ── Step 6: Return success with product access link ──
  res.json({
    success: true,
    productLink: googleDriveLink,
  });
};
